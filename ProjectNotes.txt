INTERFACE AND POLYMORPHISM

INTERFACE:
Interface:
    - An interface is like a blueprint that defines methods and properties a class must have but it doesn't provide the actual code for them.
    - It's used to ensure different classes follow the same rules.

Why Use An Interface:
    Abstraction: 
        - Defines what methods a class should implement without specifying how.
        - Interfaces tell classes what they need to do, but not how to do it.
    Polymorphism:
        - Allows different classes to be treated as instances of the interface type.
        - Interface let different classes be used in the same way.
    Decoupling:
        - Reduces dependencies between classes, making the code more modular and easier to maintain.
        - Interfaces help keep classes separate so the code is easier to manage and update.
    Reusability:
        - Ensures that different classes can use comming methods, enhancing code reusability.
        - Interface make it easy to reuse code across different classes.

POLYMORHPISM:
Polymorphism:
    - Derived from the Greek word meaning "many shapes".
    - Refers to the ability in programming where a single interface or method can operate in multiple ways based on the object it interacts with.
    - The same method works uniqely different depending on the object it controls.

One Interface, Many Implementations:
    - A single function or method can handle objects of various types.
    - The implementation depends on the specific object being referenced.

Why Use Polymorphism:
    Flexibility:
        - Write adapatable and reusable code.
        - Methods can work with different object types without knowing the specific types in advance.
    Code Maintenance:
        - Simplifies maintenance and extension.
        - New object types can be added easily if they conform to the expected interface or base class.
    Simplifies the Code:
        - Enables treating different objects uniformly

Where:
    - When you need different classes to implement the same set of methods or properties.
    - This ensures consistency and allows for flexible implementations.
Why:
    - Promotes code reusability and flexibility.
    - Different classes can implement the same interface in various ways, allowing for diverse
      behavior while maintaining a common contract.
 When:
    - Use interfaces when you have multiple classes that should provide the same functionality but might implement it differently.
    - Real-world example: Payment Processing System     

FILE CLASS:
AppendAllText:
    - Using the File class, we can write a long message to a log file.
    - The AppendAllText method will create the file if it doesn't exist, or append to it if it does.
    - The first argument is the file name, and the second argument is the message we want to write, followed by a newline character for better readability.
    - Example:
        - File.AppendAllText("log.txt", "Hello World!");

Decoupling:
    - By using interfaces and polymorphism, we can decouple a class by depending on the interface
      rather than the specific implementation. 
    - This means you can easily swap out different implementations 
      without changing the code that uses it, making your code more flexible and maintainable.

Dependency Injection:
    - A programming technique that makes a class independent of its dependencies by injecting those 
      dependencies from the outside rather than creating them internally.
    - By using interfaces and polymorphism, we can implement dependency injection, 
      which is a design pattern that allows us to inject dependencies into a class rather than having the class create them

Constructor Injection:
    - Dependencies are provided through a class constructor, ensuring that the class receives all its dependencies at the time of instantiation.
Setter Injection:
    - Dependencies are assigned to public setter methods, allowing for the injection of dependencies after the object is created.
Interface Injection:
    - Dependencies are provided through an interface, requiring the class to implement an interface that exposes a method for injecting the dependency.